use dsp::osc_utils::polyblep2_residual;

#[derive(Default, Debug, Clone)]
pub struct Oscillator {
    phase: f32,
}

fn saw(phase: f32, increment: f32) -> f32 {
    (phase - 0.5) * 2.0 - polyblep2_residual(phase, increment)
}

fn rotate(phase: f32, x: f32) -> f32 {
    let phase = phase + (1.0 - x);
    if phase > 1.0 { phase - 1.0 } else { phase }
}

#[must_use]
pub fn pulse(phase: f32, increment: f32, width: f32) -> f32 {
    if width < increment {
        -1.0
    } else if width > 1.0 - increment {
        1.0
    } else {
        (if phase < width { -1.0 } else { 1.0 }) - polyblep2_residual(phase, increment)
            + polyblep2_residual(rotate(phase, width), increment)
    }
}

#[derive(Default, Debug, Clone, Copy, PartialEq)]
pub struct Settings {
    pub increment: f32,

    pub shape: Shape,

    pub gain: f32,

    /// For width-modulatable shapes, the current width
    pub width: f32,
}

impl Oscillator {
    pub fn reset(&mut self) {
        *self = Self::default();
    }

    pub fn generate(
        &mut self,
        Settings {
            increment,
            shape,
            gain,
            width,
        }: &Settings,
    ) -> f32 {
        assert!(*increment > 0.0 && *increment < 1.0);
        let ret = match shape {
            Shape::Saw => saw(self.phase, *increment) * *gain,
            Shape::Pulse => pulse(self.phase, *increment, *width) * *gain,
            _ => 0.0,
        };
        self.phase += *increment;
        if self.phase > 1.0 {
            self.phase -= 1.0;
        }
        ret
    }
}

#[derive(Default, Debug, Clone, Copy, PartialEq)]
pub enum Shape {
    /// Standard sawtooth wave
    #[default]
    Saw,

    /// Pulse wave (width-modulatable)
    Pulse,

    /// Saw with width-modulation
    PwmSaw,

    /// Saw made out of comb-like pulses
    CombSaw,

    /// Noise as generated by a linear feedback shift register IC (mm5437)
    Noise,
}

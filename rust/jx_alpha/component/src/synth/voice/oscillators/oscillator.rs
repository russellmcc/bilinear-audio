use dsp::osc_utils::{polyblamp2_residual, polyblep2_residual};

#[derive(Default, Debug, Clone)]
pub struct Oscillator {
    phase: f32,
}

#[must_use]
fn saw(phase: f32, increment: f32) -> f32 {
    (phase - 0.5) * 2.0 - polyblep2_residual(phase, increment)
}

#[must_use]
fn rotate(phase: f32, x: f32) -> f32 {
    let phase = phase + (1.0 - x);
    if phase > 1.0 { phase - 1.0 } else { phase }
}

#[must_use]
pub fn pulse(phase: f32, increment: f32, width: f32) -> f32 {
    if width < increment {
        -1.0
    } else if width > 1.0 - increment {
        1.0
    } else {
        (if phase < width { -1.0 } else { 1.0 }) - polyblep2_residual(phase, increment)
            + polyblep2_residual(rotate(phase, width), increment)
    }
}

#[must_use]
pub fn pwm_saw(phase: f32, increment: f32, width: f32) -> f32 {
    // Naive waveform generation
    let naive_signal = if phase < width / 2.0 {
        -1.0
    } else if phase < 0.5 {
        (phase - 0.5) * 2.0
    } else if phase < (width + 1.0) / 2.0 {
        -1.0
    } else {
        // phase >= (width + 1.0) / 2.0
        (phase - 0.5) * 2.0
    };

    let mut output = naive_signal;

    // discontinuity at phase = 0.0
    output -= polyblep2_residual(phase, increment);
    output -= 0.5 * polyblamp2_residual(phase, increment);

    // discontinuity at phase = 0.5 * width
    let p1 = 0.5 * width;
    let t1 = rotate(phase, p1);
    output += p1 * polyblep2_residual(t1, increment);
    output += 0.5 * polyblamp2_residual(t1, increment);

    // discontinuity at phase = 0.5
    let t2 = rotate(phase, 0.5);
    output -= 0.5 * polyblep2_residual(t2, increment);
    output -= 0.5 * polyblamp2_residual(t2, increment);

    // discontinuity at phase = 0.5 + 0.5 * width
    let p3 = 0.5 * (width + 1.0);
    let t3 = rotate(phase, p3);
    output += p3 * polyblep2_residual(t3, increment);
    output += 0.5 * polyblamp2_residual(t3, increment);

    output
}

#[derive(Default, Debug, Clone, Copy, PartialEq)]
pub struct Settings {
    pub increment: f32,

    pub shape: Shape,

    pub gain: f32,

    /// For width-modulatable shapes, the current width
    pub width: f32,
}

impl Oscillator {
    pub fn reset(&mut self) {
        *self = Self::default();
    }

    pub fn generate(
        &mut self,
        Settings {
            increment,
            shape,
            gain,
            width,
        }: &Settings,
    ) -> f32 {
        assert!(*increment > 0.0 && *increment < 1.0);
        let ret = match shape {
            Shape::Saw => saw(self.phase, *increment) * *gain,
            Shape::Pulse => pulse(self.phase, *increment, *width) * *gain,
            Shape::PwmSaw => pwm_saw(self.phase, *increment, *width) * *gain,
            _ => 0.0,
        };
        self.phase += *increment;
        if self.phase > 1.0 {
            self.phase -= 1.0;
        }
        ret
    }
}

#[derive(Default, Debug, Clone, Copy, PartialEq)]
pub enum Shape {
    /// Standard sawtooth wave
    #[default]
    Saw,

    /// Pulse wave (width-modulatable)
    Pulse,

    /// Saw with width-modulation
    PwmSaw,

    /// Saw made out of comb-like pulses
    CombSaw,

    /// Noise as generated by a linear feedback shift register IC (mm5437)
    Noise,
}
